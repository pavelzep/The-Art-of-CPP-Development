Сложность решения задачи «Система бронирования отелей»

Используйте следующие обозначения:
Q — количество запросов
T — максимальное значение модуля времени (то есть −T ⩽ time ⩽ T)
L — максимальная длина строки с названием отеля
С — максимальное значение client_id
R — максимальное количество комнат, бронируемых за один запрос
W — размер временно́го окна (в данном случае равный 86400)

Выберите один вариант из списка

QR(L + logQ)
QC
QL + W
Q(R + L logQ)
QL
Q logQ
Q logQ + T
QW
QR logQ
QC logQ
Q logL
Q(L + logQ)
Q(W + logQ)
Q(R + logL)
QL logL + C
QL logQ + W
Q logL + W
Q(R + logQ)
Q logL + C
QL logL
Q(R + L logL)
(QL + T) logQ
Q(W + L logQ)
QL logQ !!!!!!!!!!!!!!!!!!!!!

Действительно. Исходя из кода в main, можно заметить, что общая сложность определяется как суммарная сложность всех вызовов методов Book, ComputeClientCount и ComputeRoomCount класса HotelManager, которые определяются значением ключа query_type. Оценим суммарные сложности всех потенциальных вызовов каждого из указанных методов, опуская несущественные, с точки зрения асимптотики, участки кода. Book: Поиск названия отеля по словарю hotels_ : O(L logQ). Полагаем, что отелей не могло быть создано больше, чем было запросов. Запросов по условию не более Q. O(L) присутствует в оценке, так как для поиска в map'е мы сравниваем между собой строковые ключи, длина которых не превосходит L. Вызов метода Book класса HotelInfo. Поиск клиента в словаре client_booking_counts_ займет не более O(logQ). Клиентов, вообще говоря, также не могло быть создано больше, чем было запросов. Итого, суммарная оценка одного вызова метода Book класса HotelManager: O(L logQ) + O(logQ) = O(L logQ) путём поглощения. Всего вызовов метода Book класса HotelManager не могло быть более Q: таким образом, итоговая оценка сложности всех потенциальных вызовов указанного метода Book: O(QL logQ). ComputeClientCount, ComputeRoomCount: Сложность работы данных методов, вообще говоря, определяется в обоих случаях, как и в случае с методом Book, суммой сложности поиска названия отеля по словарю hotels_ и сложности метода RemoveOldBookings. Сложность RemoveOldBookings, в свою очередь, зависит от сложности метода PopBooking. При этом, несмотря на цикл, суммарно метод RemoveOldBookings вызовет метод PopBooking за время работы приложения не более Q раз, так как каждое добавленное событие может быть удалено не более одного раза. Сложность метода PopBooking зависит от поиска и удаления в словаре client_booking_counts_. Поиск оценивается, как O(logQ), удаление — аналогично. Суммарное время работы PopBooking: O(logQ) + O(logQ) = O(logQ) путём поглощения. Таким образом, итоговая оценка сложности всех потенциальных вызовов метода RemoveOldBooking: O(Q logQ), а методов ComputeClientCount, ComputeRoomCount: O(QL logQ) + O(Q logQ) = O(QL log Q) путём поглощения. Итого, путём поглощения получаем итоговую оценку O(QL logQ). Величины T, C и W в оценке сложности не участвуют: T и C определяют лишь необходимую размерность типов, а W влияет лишь на количество удалений: чем больше W, тем меньше в конечном счёте будет вызовов методов PopBooking.

QL + C
Q logQ + W
QC logL
QL logQ + C
QR(logQ + logL)
Q(R + L)
Q logQ + C
QL logQ + T
QL logL + W

Задание по программированию «Система бронирования отелей»
 

Условие
Разработайте систему бронирования отелей, позволяющую бронировать номера клиентами и контролировать спрос владельцами отелей.
 Ваша программа должна обрабатывать следующие события:

BOOK time hotel_name client_id room_count — забронировать клиентом client_id room_count номеров в отеле hotel_name в момент времени time.
 Время измеряется в секундах, отсчитываемых от некоторого момента.

CLIENTS hotel_name — вывести количество различных клиентов, 
бронировавших номера в отеле hotel_name за последние сутки. 
Более формально интересующий диапазон времени описывается следующим образом: 
пусть current_time — время последнего события BOOK, 
тогда в данном запросе нужно учесть все события с current_time − 86400 < time ⩽ current_time, 
где 86400 — количество секунд в сутках. Обратите внимание, 
что последнее бронирование должно учитываться, а бронирование, 
случившееся ровно за сутки до него, учитываться не должно.

ROOMS hotel_name — вывести количество номеров, забронированных за последние сутки в отеле hotel_name.

Формат входных данных
В первой строке вводится количество запросов Q — натуральное число, не превосходящее 10^5. 
В следующих Q строках в соответствии с описанным выше форматом вводятся запросы. Гарантируется, что:

time — целое число в диапазоне от −10^18 до 10^18 и не убывает от события к событию.

hotel_name — строка из латинских букв и цифр, имеющая длину не более 12 символов.

client_id — натуральное число, не превосходящее 10^9.

room_count — целое положительное число, не превосходящее 1000.

Формат выходных данных
Для каждого запроса CLIENTS и ROOMS выведите единственное целое число — ответ на запрос. 
Если указанный в запросе отель пока не имеет ни одного бронирования, выведите 0.

Ограничения
1 секунда на выполнение всех запросов. 
Все описанные в условии гарантии действительно справедливы для всех тестов, 
на которых будет запускаться ваша программа. Проверять корректность тестов не нужно.

Пример
Ввод
11
CLIENTS Marriott
ROOMS Marriott
BOOK 10 FourSeasons 1 2
BOOK 10 Marriott 1 1
BOOK 86409 FourSeasons 2 1
CLIENTS FourSeasons
ROOMS FourSeasons
CLIENTS Marriott
BOOK 86410 Marriott 2 10
ROOMS FourSeasons
ROOMS Marriott
 

Вывод
0
0
2
3
1
1
10
 

Комментарии к примеру
После бронирования, случившегося в момент времени 86410, в статистике перестают учитываться бронирования, случившиеся в момент времени 10. 