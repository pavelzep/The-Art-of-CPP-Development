Рассмотрим следующий способ реализовать вариант метода splice, рассмотренный в предыдущем вопросе — splice(pos, other, first, last).

    Указателю с prev(pos) на следующий элемент присвоим адрес ячейки first.

    Указателю с pos на предыдущий элемент присвоим адрес ячейки prev(last).

    Указателю с first на предыдущий элемент присвоим адрес ячейки prev(pos).

    Указателю с prev(last) на следующий элемент присвоим адрес ячейки pos.

    Указателю с prev(first) на следующий элемент присвоим адрес ячейки last.

    Указателю с last на предыдущий элемент присвоим адрес ячейки prev(first).

Алгоритм описан без учёта крайних случаев (например, когда first указывает на первый элемент своего списка), но суть остаётся прежней — такой алгоритм позволяет реализовать splice за константное время, а не за линейное, как заявлено в документации.

Отметьте, какая часть функциональности пострадает, если модифицировать метод splice таким образом.

Разворот списка методом reverse не сможет гарантировать неинвалидацию всех ссылок.
Метод splice не сможет гарантировать неинвалидацию всех ссылок.
Разворот списка методом reverse не получится выполнять так же эффективно, как раньше.
Добавление элемента в начало или конец не получится выполнять так же эффективно, как раньше.
Никакая часть функциональности не пострадает
Итерирование по списку не получится выполнять так же эффективно, как раньше.
Добавление элемента в произвольное место списка не сможет гарантировать неинвалидацию всех ссылок.
Вычисление размера списка методом size не получится выполнять так же эффективно, как раньше.
Добавление элемента в произвольное место списка не получится выполнять так же эффективно, как раньше